import { PersistenceAdapter, Settings, Customer, Package, Offer, Invoice, Timesheet, Activity, TimesheetActivity } from "../persistence/adapter";
import initSqlJs, { type Database, type SqlJsStatic } from "sql.js";
import type { ListPreferences, EntityKey, ListPreference } from "../lib/listPreferences";

function nowIso() {
  return new Date().toISOString();
}

export class SQLiteAdapter implements PersistenceAdapter {
  private SQL: SqlJsStatic | null = null;
  private db: Database | null = null;
  private persistTimer: NodeJS.Timeout | null = null;
  
  async ready(): Promise<void> {
    console.log('üîÑ [SQLiteAdapter] Initializing with IPC-based file persistence');
    
    // Initialize sql.js
    if (!this.SQL) {
      this.SQL = await initSqlJs({
        locateFile: (_file: string) => `${import.meta.env.BASE_URL}sql-wasm.wasm`,
      });
    }
    
    // Load database from file system via IPC
    try {
      const data = await window.rawalite.db.load();
      if (data) {
        console.log(`üìÑ [SQLiteAdapter] Loaded database from file (${data.length} bytes)`);
        this.db = new this.SQL.Database(data);
      } else {
        console.log('üÜï [SQLiteAdapter] Creating new database');
        this.db = new this.SQL.Database();
        this.createSchemaIfNeeded();
        await this.persistToDisk(); // Save initial schema
      }
    } catch (error) {
      console.error('‚ùå [SQLiteAdapter] Failed to load from file, creating new database:', error);
      this.db = new this.SQL.Database();
      this.createSchemaIfNeeded();
    }
    
    this.setupAutoSave();
  }
  
  // ‚ú® NEW: IPC-based disk persistence
  private async persistToDisk(): Promise<void> {
    if (!this.db) return;
    
    try {
      const data = this.db.export();
      console.log(`üíæ [SQLiteAdapter] Persisting to disk (${data.length} bytes)`);
      await window.rawalite.db.save(data);
      console.log('‚úÖ [SQLiteAdapter] Successfully persisted to disk');
    } catch (error) {
      console.error('‚ùå [SQLiteAdapter] Failed to persist to disk:', error);
      throw error;
    }
  }
  
  // ‚ú® NEW: Debounced auto-save to prevent too frequent disk writes
  private schedulePersist(): void {
    if (this.persistTimer) {
      clearTimeout(this.persistTimer);
    }
    
    this.persistTimer = setTimeout(async () => {
      try {
        await this.persistToDisk();
      } catch (error) {
        console.error('‚ùå [SQLiteAdapter] Scheduled persist failed:', error);
      }
    }, 500); // 500ms debounce for better performance than LocalStorage's 250ms
  }
  
  // ‚ú® NEW: Setup automatic saving after mutations
  private setupAutoSave(): void {
    if (!this.db) return;
    
    const originalExec = this.db.exec.bind(this.db);
    this.db.exec = (...args: Parameters<Database["exec"]>) => {
      const result = originalExec(...args);
      const sqlText = String(args[0] ?? "").toUpperCase();
      if (/INSERT|UPDATE|DELETE|REPLACE|CREATE|DROP|ALTER/.test(sqlText)) {
        console.log(`üîÑ [SQLiteAdapter] Mutation detected, scheduling persist`);
        this.schedulePersist();
      }
      return result;
    };
    
    // Install beforeunload handler for final save
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => {
        console.log('üö® [SQLiteAdapter] App closing - forcing final persist');
        if (this.persistTimer) {
          clearTimeout(this.persistTimer);
        }
        // Note: beforeunload should be synchronous, but we'll try our best
        this.persistToDisk().catch(console.error);
      });
    }
  }
  
  // ‚ú® NEW: Manual force persist (called by IPC)
  async forcePersist(): Promise<void> {
    console.log('üö® [SQLiteAdapter] Force persist requested');
    if (this.persistTimer) {
      clearTimeout(this.persistTimer);
      this.persistTimer = null;
    }
    await this.persistToDisk();
  }
  
  // ‚ú® NEW: Database helper functions (replacing imports from sqlite/db)
  private all<T = any>(sql: string, params: any[] = []): T[] {
    if (!this.db) throw new Error("Database not initialized");
    const stmt = this.db.prepare(sql);
    try {
      stmt.bind(params);
      const rows: T[] = [];
      while (stmt.step()) rows.push(stmt.getAsObject() as T);
      return rows;
    } finally {
      stmt.free();
    }
  }
  
  private run(sql: string, params: any[] = []): void {
    if (!this.db) throw new Error("Database not initialized");
    const stmt = this.db.prepare(sql);
    try {
      stmt.bind(params);
      stmt.step();
    } finally {
      stmt.free();
    }
  }
  
  // Transaction state tracking to prevent nested transactions
  private inTransaction = false;
  
  private async withTx<T>(fn: () => T | Promise<T>): Promise<T> {
    if (!this.db) throw new Error("Database not initialized");
    
    // If we're already in a transaction, just execute the function
    if (this.inTransaction) {
      console.warn('‚ö†Ô∏è [SQLiteAdapter] Skipping nested transaction - executing directly within current transaction');
      return await fn();
    }
    
    // Start new transaction
    console.log('üîÑ [SQLiteAdapter] Starting new transaction');
    this.inTransaction = true;
    this.db.exec("BEGIN");
    try {
      const res = await fn();
      this.db.exec("COMMIT");
      console.log('‚úÖ [SQLiteAdapter] Transaction committed successfully');
      return res;
    } catch (e) {
      console.error('‚ùå [SQLiteAdapter] Transaction failed, rolling back:', e);
      this.db.exec("ROLLBACK");
      throw e;
    } finally {
      this.inTransaction = false;
    }
  }
  
  private createSchemaIfNeeded(): void {
    if (!this.db) return;
    
    console.log('üîß [SQLiteAdapter] Creating database schema');
    
    // First, create basic schema
    this.db.exec(`
      PRAGMA journal_mode = WAL;

      CREATE TABLE IF NOT EXISTS settings (
        id INTEGER PRIMARY KEY CHECK (id = 1),
        companyName TEXT, street TEXT, zip TEXT, city TEXT, 
        phone TEXT, email TEXT, website TEXT,
        taxId TEXT, vatId TEXT,
        kleinunternehmer INTEGER DEFAULT 1,
        bankName TEXT, bankAccount TEXT, bankBic TEXT,
        logo TEXT,
        designSettings TEXT,
        nextCustomerNumber INTEGER DEFAULT 1,
        nextOfferNumber INTEGER DEFAULT 1,
        nextInvoiceNumber INTEGER DEFAULT 1,
        nextTimesheetNumber INTEGER DEFAULT 1,
        createdAt TEXT, updatedAt TEXT
      );

      INSERT INTO settings (id, createdAt, updatedAt)
      SELECT 1, datetime('now'), datetime('now')
      WHERE NOT EXISTS (SELECT 1 FROM settings WHERE id = 1);
    `);

    // Add migration columns with better error handling
    try {
      const settingsInfo = this.db.exec(`PRAGMA table_info(settings)`);
      let hasTimesheetNumberColumn = false;
      let hasDesignSettingsColumn = false;
      
      if (settingsInfo.length > 0 && settingsInfo[0].values) {
        hasTimesheetNumberColumn = settingsInfo[0].values.some((row: any[]) => row[1] === 'nextTimesheetNumber');
        hasDesignSettingsColumn = settingsInfo[0].values.some((row: any[]) => row[1] === 'designSettings');
      }
      
      if (!hasTimesheetNumberColumn) {
        this.db.exec(`ALTER TABLE settings ADD COLUMN nextTimesheetNumber INTEGER DEFAULT 1;`);
        console.log('‚úÖ [SQLiteAdapter] Added nextTimesheetNumber column to settings table');
      }
      
      if (!hasDesignSettingsColumn) {
        this.db.exec(`ALTER TABLE settings ADD COLUMN designSettings TEXT;`);
        console.log('‚úÖ [SQLiteAdapter] Added designSettings column to settings table');
        
        // ‚ú® CRITICAL: Nach Hinzuf√ºgung der Spalte sofort Default-Werte setzen
        const defaultDesignSettings = JSON.stringify({
          theme: 'salbeigr√ºn',
          navigationMode: 'sidebar'
        });
        
        try {
          this.run(`UPDATE settings SET designSettings = ? WHERE id = 1 AND (designSettings IS NULL OR designSettings = '')`, [defaultDesignSettings]);
          console.log('‚úÖ [SQLiteAdapter] Initialized default design settings in database');
        } catch (updateError) {
          console.warn('‚ö†Ô∏è [SQLiteAdapter] Could not initialize default design settings:', updateError);
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SQLiteAdapter] Settings table migration error:', error);
    }

    this.db.exec(`
      CREATE TABLE IF NOT EXISTS customers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        number TEXT NOT NULL UNIQUE,
        name TEXT NOT NULL,
        email TEXT, phone TEXT,
        street TEXT, zip TEXT, city TEXT,
        notes TEXT,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );
      
      CREATE TABLE IF NOT EXISTS packages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        number TEXT NOT NULL UNIQUE,
        name TEXT NOT NULL,
        description TEXT,
        notes TEXT,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS package_line_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        packageId INTEGER NOT NULL REFERENCES packages(id) ON DELETE CASCADE,
        parentId INTEGER REFERENCES package_line_items(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        quantity REAL DEFAULT 1,
        unit TEXT DEFAULT 'St√ºck',
        unitPrice REAL DEFAULT 0,
        total REAL DEFAULT 0,
        sortOrder INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS offers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        offerNumber TEXT NOT NULL UNIQUE,
        customerId INTEGER NOT NULL REFERENCES customers(id),
        title TEXT NOT NULL,
        description TEXT,
        notes TEXT,
        status TEXT NOT NULL DEFAULT 'draft',
        validUntil TEXT,
        subtotal REAL DEFAULT 0,
        taxRate REAL DEFAULT 19.0,
        taxAmount REAL DEFAULT 0,
        total REAL DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS offer_line_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        offerId INTEGER NOT NULL REFERENCES offers(id) ON DELETE CASCADE,
        parentId INTEGER REFERENCES offer_line_items(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        quantity REAL DEFAULT 1,
        unit TEXT DEFAULT 'St√ºck',
        unitPrice REAL DEFAULT 0,
        total REAL DEFAULT 0,
        sortOrder INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS invoices (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        invoiceNumber TEXT NOT NULL UNIQUE,
        customerId INTEGER NOT NULL REFERENCES customers(id),
        offerId INTEGER REFERENCES offers(id),
        title TEXT NOT NULL,
        description TEXT,
        notes TEXT,
        status TEXT NOT NULL DEFAULT 'draft',
        invoiceDate TEXT NOT NULL,
        dueDate TEXT,
        subtotal REAL DEFAULT 0,
        taxRate REAL DEFAULT 19.0,
        taxAmount REAL DEFAULT 0,
        total REAL DEFAULT 0,
        paidAt TEXT,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS invoice_line_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        invoiceId INTEGER NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
        parentId INTEGER REFERENCES invoice_line_items(id) ON DELETE CASCADE,
        title TEXT NOT NULL,
        description TEXT,
        quantity REAL DEFAULT 1,
        unit TEXT DEFAULT 'St√ºck',
        unitPrice REAL DEFAULT 0,
        total REAL DEFAULT 0,
        sortOrder INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS timesheets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timesheetNumber TEXT NOT NULL UNIQUE,
        customerId INTEGER NOT NULL REFERENCES customers(id),
        title TEXT NOT NULL,
        description TEXT,
        notes TEXT,
        status TEXT NOT NULL DEFAULT 'draft',
        startDate TEXT,
        endDate TEXT,
        totalHours REAL DEFAULT 0,
        hourlyRate REAL DEFAULT 0,
        subtotal REAL DEFAULT 0,
        taxRate REAL DEFAULT 19.0,
        taxAmount REAL DEFAULT 0,
        total REAL DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_timesheets_customer ON timesheets(customerId);
      CREATE INDEX IF NOT EXISTS idx_timesheets_status ON timesheets(status);
      CREATE INDEX IF NOT EXISTS idx_timesheets_dates ON timesheets(startDate, endDate);

      -- Activities und Timesheet-Activities
      CREATE TABLE IF NOT EXISTS activities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        defaultHourlyRate REAL DEFAULT 0,
        isActive INTEGER DEFAULT 1,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      );

      CREATE TABLE IF NOT EXISTS timesheet_activities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timesheetId INTEGER NOT NULL REFERENCES timesheets(id) ON DELETE CASCADE,
        activityId INTEGER NOT NULL REFERENCES activities(id),
        hours REAL DEFAULT 0,
        hourlyRate REAL DEFAULT 0,
        total REAL DEFAULT 0,
        description TEXT,
        position TEXT
      );

      CREATE INDEX IF NOT EXISTS idx_timesheet_activities_timesheet ON timesheet_activities(timesheetId);
      CREATE INDEX IF NOT EXISTS idx_timesheet_activities_activity ON timesheet_activities(activityId);

      -- Add position column to existing timesheet_activities table (migration)
      -- This is handled by the migration check below
      PRAGMA table_info(timesheet_activities);
    `);

    // Check if position column exists and add it if not (for existing databases)
    try {
      const columns = this.all<any>("PRAGMA table_info(timesheet_activities)");
      const hasPositionColumn = columns.some((col: any) => col.name === 'position');
      if (!hasPositionColumn) {
        this.db.exec("ALTER TABLE timesheet_activities ADD COLUMN position TEXT");
        console.log('‚úÖ [SQLiteAdapter] Added position column to timesheet_activities table');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SQLiteAdapter] Migration warning (position column):', error);
    }

    // List preferences migration
    try {
      const columns = this.all<any>("PRAGMA table_info(settings)");
      const hasListPreferences = columns.some((col: any) => col.name === 'listPreferences');
      if (!hasListPreferences) {
        this.db.exec("ALTER TABLE settings ADD COLUMN listPreferences TEXT DEFAULT '{}'");
        console.log('‚úÖ [SQLiteAdapter] Added listPreferences column to settings table');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è [SQLiteAdapter] Migration warning (listPreferences):', error);
      console.warn('‚ö†Ô∏è [SQLiteAdapter] App will continue but list preferences may not persist');
      
      // Try alternative approach - direct SQL without helpers
      try {
        if (this.db) {
          this.db.exec("ALTER TABLE settings ADD COLUMN listPreferences TEXT DEFAULT '{}'");
          console.log('‚úÖ [SQLiteAdapter] Alternative migration successful');
        }
      } catch (altError) {
        console.warn('‚ö†Ô∏è [SQLiteAdapter] Alternative migration also failed:', altError);
        // Continue - app can function without persistent list preferences
      }
    }
    
    console.log('‚úÖ [SQLiteAdapter] Database schema created/updated successfully');
  }

  // SETTINGS
  async getSettings(): Promise<Settings> {
    const rows = this.all<Settings>("SELECT * FROM settings WHERE id = 1");
    
    // Fallback: Falls keine Settings existieren, Standard-Settings zur√ºckgeben
    if (!rows || rows.length === 0) {
      console.warn('‚ö†Ô∏è No settings found in database, creating default settings');
      const defaultSettings: Settings = {
        id: 1,
        companyName: '',
        street: '',
        zip: '',
        city: '',
        taxId: '',
        kleinunternehmer: true,
        nextCustomerNumber: 1,
        nextOfferNumber: 1,
        nextInvoiceNumber: 1,
        nextTimesheetNumber: 1,
        createdAt: nowIso(),
        updatedAt: nowIso()
      };
      
      // Erstelle Standard-Settings in der Datenbank
      run(`
        INSERT INTO settings (
          id, companyName, street, zip, city, taxId, kleinunternehmer,
          nextCustomerNumber, nextOfferNumber, nextInvoiceNumber, nextTimesheetNumber,
          createdAt, updatedAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        1, '', '', '', '', '', 1, 1, 1, 1, 1,
        defaultSettings.createdAt, defaultSettings.updatedAt
      ]);
      
      return defaultSettings;
    }
    
    return rows[0] as Settings;
  }

  async updateSettings(patch: Partial<Settings>): Promise<Settings> {
    return withTx(async () => {
      const current = await this.getSettings();
      const next = { ...current, ...patch, updatedAt: nowIso() };

      run(
        `
        UPDATE settings SET
          companyName = ?, street = ?, zip = ?, city = ?, taxId = ?,
          kleinunternehmer = ?, nextCustomerNumber = ?, nextOfferNumber = ?, nextInvoiceNumber = ?, nextTimesheetNumber = ?,
          listPreferences = ?, updatedAt = ?
        WHERE id = 1
      `,
        [
          next.companyName ?? null,
          next.street ?? null,
          next.zip ?? null,
          next.city ?? null,
          next.taxId ?? null,
          next.kleinunternehmer ? 1 : 0,
          next.nextCustomerNumber ?? 1,
          next.nextOfferNumber ?? 1,
          next.nextInvoiceNumber ?? 1,
          next.nextTimesheetNumber ?? 1,
          next.listPreferences ?? '{}',
          next.updatedAt,
        ]
      );
      return next;
    });
  }

  // CUSTOMERS
  async listCustomers(): Promise<Customer[]> {
    await getDB();
    return all<Customer>(`SELECT * FROM customers ORDER BY createdAt DESC`);
  }

  async getCustomer(id: number): Promise<Customer | null> {
    await getDB();
    const rows = all<Customer>(`SELECT * FROM customers WHERE id = ?`, [id]);
    return rows[0] ?? null;
  }

  async createCustomer(
    data: Omit<Customer, "id" | "createdAt" | "updatedAt">
  ): Promise<Customer> {
    return withTx(async () => {
      const ts = nowIso();
      run(
        `
        INSERT INTO customers (number, name, email, phone, street, zip, city, notes, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
        [
          data.number,
          data.name,
          data.email ?? null,
          data.phone ?? null,
          data.street ?? null,
          data.zip ?? null,
          data.city ?? null,
          data.notes ?? null,
          ts,
          ts,
        ]
      );
      const row = all<Customer>(`SELECT * FROM customers WHERE rowid = last_insert_rowid()`);
      return row[0];
    });
  }

  async updateCustomer(id: number, patch: Partial<Customer>): Promise<Customer> {
    return withTx(async () => {
      const current = await this.getCustomer(id);
      if (!current) throw new Error("Customer not found");

      const next: Customer = {
        ...current,
        ...patch,
        updatedAt: nowIso(),
      };

      run(
        `
        UPDATE customers SET
          number = ?, name = ?, email = ?, phone = ?, street = ?, zip = ?, city = ?, notes = ?, updatedAt = ?
        WHERE id = ?
      `,
        [
          next.number,
          next.name,
          next.email ?? null,
          next.phone ?? null,
          next.street ?? null,
          next.zip ?? null,
          next.city ?? null,
          next.notes ?? null,
          next.updatedAt,
          id,
        ]
      );

      const row = await this.getCustomer(id);
      if (!row) throw new Error("Customer update failed");
      return row;
    });
  }

  async deleteCustomer(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM customers WHERE id = ?`, [id]);
    });
  }

  // PACKAGES
  async listPackages(): Promise<Package[]> {
    await getDB();
    const packages = all<Omit<Package, "lineItems">>(`SELECT * FROM packages ORDER BY createdAt DESC`);
    
    // Load line items for each package
    const result: Package[] = [];
    for (const pkg of packages) {
      const lineItems = all<any>(`SELECT id, title, quantity, amount, parentItemId, description FROM package_line_items WHERE packageId = ? ORDER BY id`, [pkg.id]);
      result.push({
        ...pkg,
        lineItems: lineItems.map(item => ({
          id: item.id,
          title: item.title,
          quantity: item.quantity,
          amount: item.amount,
          parentItemId: item.parentItemId || undefined,
          description: item.description || undefined
        }))
      });
    }
    return result;
  }

  async getPackage(id: number): Promise<Package | null> {
    await getDB();
    const rows = all<Omit<Package, "lineItems">>(`SELECT * FROM packages WHERE id = ?`, [id]);
    if (!rows[0]) return null;
    
    const pkg = rows[0];
    const lineItems = all<any>(`SELECT id, title, quantity, amount, parentItemId, description FROM package_line_items WHERE packageId = ? ORDER BY id`, [id]);
    
    return {
      ...pkg,
      lineItems: lineItems.map(item => ({
        id: item.id,
        title: item.title,
        quantity: item.quantity,
        amount: item.amount,
        parentItemId: item.parentItemId || undefined,
        description: item.description || undefined
      }))
    };
  }

  async createPackage(data: Omit<Package, "id" | "createdAt" | "updatedAt">): Promise<Package> {
    return withTx(async () => {
      const ts = nowIso();
      
      // Insert package
      run(
        `
        INSERT INTO packages (internalTitle, parentPackageId, total, addVat, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?)
      `,
        [
          data.internalTitle,
          data.parentPackageId ?? null,
          data.total,
          data.addVat ? 1 : 0,
          ts,
          ts,
        ]
      );
      
      const packageRows = all<{ id: number }>(`SELECT id FROM packages WHERE rowid = last_insert_rowid()`);
      const packageId = packageRows[0].id;
      
      // Insert line items
      for (const item of data.lineItems) {
        run(
          `INSERT INTO package_line_items (packageId, title, quantity, amount, parentItemId, description) VALUES (?, ?, ?, ?, ?, ?)`,
          [packageId, item.title, item.quantity, item.amount, item.parentItemId || null, item.description || null]
        );
      }
      
      const newPackage = await this.getPackage(packageId);
      if (!newPackage) throw new Error("Package creation failed");
      return newPackage;
    });
  }

  async updatePackage(id: number, patch: Partial<Package>): Promise<Package> {
    return withTx(async () => {
      const current = await this.getPackage(id);
      if (!current) throw new Error("Package not found");

      const next = {
        ...current,
        ...patch,
        updatedAt: nowIso(),
      };

      // Update package
      run(
        `
        UPDATE packages SET
          internalTitle = ?, parentPackageId = ?, total = ?, addVat = ?, updatedAt = ?
        WHERE id = ?
      `,
        [
          next.internalTitle,
          next.parentPackageId ?? null,
          next.total,
          next.addVat ? 1 : 0,
          next.updatedAt,
          id,
        ]
      );

      // Update line items if provided
      if (patch.lineItems) {
        // Delete old line items
        run(`DELETE FROM package_line_items WHERE packageId = ?`, [id]);
        
        // Insert new line items
        for (const item of patch.lineItems) {
          run(
            `INSERT INTO package_line_items (packageId, title, quantity, amount, parentItemId, description) VALUES (?, ?, ?, ?, ?, ?)`,
            [id, item.title, item.quantity, item.amount, item.parentItemId || null, item.description || null]
          );
        }
      }

      const updated = await this.getPackage(id);
      if (!updated) throw new Error("Package update failed");
      return updated;
    });
  }

  async deletePackage(id: number): Promise<void> {
    await withTx(async () => {
      // Delete line items first
      run(`DELETE FROM package_line_items WHERE packageId = ?`, [id]);
      // Delete package
      run(`DELETE FROM packages WHERE id = ?`, [id]);
    });
  }

  // OFFERS
  async listOffers(): Promise<Offer[]> {
    await getDB();
    const offers = all<Omit<Offer, "lineItems">>(`SELECT * FROM offers ORDER BY createdAt DESC`);
    
    const result: Offer[] = [];
    for (const offer of offers) {
      const lineItems = all<any>(`SELECT id, title, description, quantity, unitPrice, total, parentItemId FROM offer_line_items WHERE offerId = ? ORDER BY id`, [offer.id]);
      result.push({
        ...offer,
        lineItems: lineItems.map(item => ({
          id: item.id,
          title: item.title,
          description: item.description || undefined,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          total: item.total,
          parentItemId: item.parentItemId || undefined
        }))
      });
    }
    return result;
  }

  async getOffer(id: number): Promise<Offer | null> {
    await getDB();
    const rows = all<Omit<Offer, "lineItems">>(`SELECT * FROM offers WHERE id = ?`, [id]);
    if (!rows[0]) return null;
    
    const offer = rows[0];
    const lineItems = all<any>(`SELECT id, title, description, quantity, unitPrice, total, parentItemId FROM offer_line_items WHERE offerId = ? ORDER BY id`, [id]);
    
    return {
      ...offer,
      lineItems: lineItems.map(item => ({
        id: item.id,
        title: item.title,
        description: item.description || undefined,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        total: item.total,
        parentItemId: item.parentItemId || undefined
      }))
    };
  }

  async createOffer(data: Omit<Offer, "id" | "createdAt" | "updatedAt">): Promise<Offer> {
    return withTx(async () => {
      const ts = nowIso();
      
      run(
        `
        INSERT INTO offers (offerNumber, customerId, title, status, validUntil, subtotal, vatRate, vatAmount, total, notes, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
        [
          data.offerNumber,
          data.customerId,
          data.title,
          data.status,
          data.validUntil,
          data.subtotal,
          data.vatRate,
          data.vatAmount,
          data.total,
          data.notes || null,
          ts,
          ts,
        ]
      );
      
      const offerRows = all<{ id: number }>(`SELECT id FROM offers WHERE rowid = last_insert_rowid()`);
      const offerId = offerRows[0].id;
      
      for (const item of data.lineItems) {
        run(
          `INSERT INTO offer_line_items (offerId, title, description, quantity, unitPrice, total, parentItemId) VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [offerId, item.title, item.description || null, item.quantity, item.unitPrice, item.total, item.parentItemId || null]
        );
      }
      
      const newOffer = await this.getOffer(offerId);
      if (!newOffer) throw new Error("Offer creation failed");
      return newOffer;
    });
  }

  async updateOffer(id: number, patch: Partial<Offer>): Promise<Offer> {
    return withTx(async () => {
      const current = await this.getOffer(id);
      if (!current) throw new Error("Offer not found");

      const next = { ...current, ...patch, updatedAt: nowIso() };

      run(
        `
        UPDATE offers SET
          offerNumber = ?, customerId = ?, title = ?, status = ?, validUntil = ?, 
          subtotal = ?, vatRate = ?, vatAmount = ?, total = ?, notes = ?, updatedAt = ?
        WHERE id = ?
      `,
        [
          next.offerNumber,
          next.customerId,
          next.title,
          next.status,
          next.validUntil,
          next.subtotal,
          next.vatRate,
          next.vatAmount,
          next.total,
          next.notes || null,
          next.updatedAt,
          id,
        ]
      );

      if (patch.lineItems) {
        run(`DELETE FROM offer_line_items WHERE offerId = ?`, [id]);
        for (const item of patch.lineItems) {
          run(
            `INSERT INTO offer_line_items (offerId, title, description, quantity, unitPrice, total, parentItemId) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, item.title, item.description || null, item.quantity, item.unitPrice, item.total, item.parentItemId || null]
          );
        }
      }

      const updated = await this.getOffer(id);
      if (!updated) throw new Error("Offer update failed");
      return updated;
    });
  }

  async deleteOffer(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM offer_line_items WHERE offerId = ?`, [id]);
      run(`DELETE FROM offers WHERE id = ?`, [id]);
    });
  }

  // INVOICES
  async listInvoices(): Promise<Invoice[]> {
    await getDB();
    const invoices = all<Omit<Invoice, "lineItems">>(`SELECT * FROM invoices ORDER BY createdAt DESC`);
    
    const result: Invoice[] = [];
    for (const invoice of invoices) {
      const lineItems = all<any>(`SELECT id, title, description, quantity, unitPrice, total, parentItemId FROM invoice_line_items WHERE invoiceId = ? ORDER BY id`, [invoice.id]);
      result.push({
        ...invoice,
        lineItems: lineItems.map(item => ({
          id: item.id,
          title: item.title,
          description: item.description || undefined,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          total: item.total,
          parentItemId: item.parentItemId || undefined
        }))
      });
    }
    return result;
  }

  async getInvoice(id: number): Promise<Invoice | null> {
    await getDB();
    const rows = all<Omit<Invoice, "lineItems">>(`SELECT * FROM invoices WHERE id = ?`, [id]);
    if (!rows[0]) return null;
    
    const invoice = rows[0];
    const lineItems = all<any>(`SELECT id, title, description, quantity, unitPrice, total, parentItemId FROM invoice_line_items WHERE invoiceId = ? ORDER BY id`, [id]);
    
    return {
      ...invoice,
      lineItems: lineItems.map(item => ({
        id: item.id,
        title: item.title,
        description: item.description || undefined,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        total: item.total,
        parentItemId: item.parentItemId || undefined
      }))
    };
  }

  async createInvoice(data: Omit<Invoice, "id" | "createdAt" | "updatedAt">): Promise<Invoice> {
    return withTx(async () => {
      const ts = nowIso();
      
      run(
        `
        INSERT INTO invoices (invoiceNumber, customerId, offerId, title, status, dueDate, subtotal, vatRate, vatAmount, total, notes, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
        [
          data.invoiceNumber,
          data.customerId,
          data.offerId || null,
          data.title,
          data.status,
          data.dueDate,
          data.subtotal,
          data.vatRate,
          data.vatAmount,
          data.total,
          data.notes || null,
          ts,
          ts,
        ]
      );
      
      const invoiceRows = all<{ id: number }>(`SELECT id FROM invoices WHERE rowid = last_insert_rowid()`);
      const invoiceId = invoiceRows[0].id;
      
      for (const item of data.lineItems) {
        run(
          `INSERT INTO invoice_line_items (invoiceId, title, description, quantity, unitPrice, total, parentItemId) VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [invoiceId, item.title, item.description || null, item.quantity, item.unitPrice, item.total, item.parentItemId || null]
        );
      }
      
      const newInvoice = await this.getInvoice(invoiceId);
      if (!newInvoice) throw new Error("Invoice creation failed");
      return newInvoice;
    });
  }

  async updateInvoice(id: number, patch: Partial<Invoice>): Promise<Invoice> {
    return withTx(async () => {
      const current = await this.getInvoice(id);
      if (!current) throw new Error("Invoice not found");

      const next = { ...current, ...patch, updatedAt: nowIso() };

      run(
        `
        UPDATE invoices SET
          invoiceNumber = ?, customerId = ?, offerId = ?, title = ?, status = ?, dueDate = ?, 
          subtotal = ?, vatRate = ?, vatAmount = ?, total = ?, notes = ?, updatedAt = ?
        WHERE id = ?
      `,
        [
          next.invoiceNumber,
          next.customerId,
          next.offerId || null,
          next.title,
          next.status,
          next.dueDate,
          next.subtotal,
          next.vatRate,
          next.vatAmount,
          next.total,
          next.notes || null,
          next.updatedAt,
          id,
        ]
      );

      if (patch.lineItems) {
        run(`DELETE FROM invoice_line_items WHERE invoiceId = ?`, [id]);
        for (const item of patch.lineItems) {
          run(
            `INSERT INTO invoice_line_items (invoiceId, title, description, quantity, unitPrice, total, parentItemId) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, item.title, item.description || null, item.quantity, item.unitPrice, item.total, item.parentItemId || null]
          );
        }
      }

      const updated = await this.getInvoice(id);
      if (!updated) throw new Error("Invoice update failed");
      return updated;
    });
  }

  async deleteInvoice(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM invoice_line_items WHERE invoiceId = ?`, [id]);
      run(`DELETE FROM invoices WHERE id = ?`, [id]);
    });
  }

  // TIMESHEETS
  async listTimesheets(): Promise<Timesheet[]> {
    await getDB();
    const timesheets = all<Omit<Timesheet, "activities">>(`SELECT * FROM timesheets ORDER BY createdAt DESC`);
    
    const result: Timesheet[] = [];
    for (const timesheet of timesheets) {
      const activities = await this.getTimesheetActivities(timesheet.id);
      result.push({
        ...timesheet,
        activities
      });
    }
    return result;
  }

  async getTimesheet(id: number): Promise<Timesheet | null> {
    await getDB();
    const rows = all<Omit<Timesheet, "activities">>(`SELECT * FROM timesheets WHERE id = ?`, [id]);
    if (!rows[0]) return null;
    
    const timesheet = rows[0];
    const activities = await this.getTimesheetActivities(id);
    
    return {
      ...timesheet,
      activities
    };
  }

  async createTimesheet(data: Omit<Timesheet, "id" | "createdAt" | "updatedAt">): Promise<Timesheet> {
    return withTx(async () => {
      const ts = nowIso();
      
      run(
        `
        INSERT INTO timesheets (timesheetNumber, customerId, title, status, startDate, endDate, subtotal, vatRate, vatAmount, total, notes, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `,
        [
          data.timesheetNumber,
          data.customerId,
          data.title,
          data.status,
          data.startDate,
          data.endDate,
          data.subtotal,
          data.vatRate,
          data.vatAmount,
          data.total,
          data.notes || null,
          ts,
          ts,
        ]
      );
      
      const timesheetRows = all<{ id: number }>(`SELECT id FROM timesheets WHERE rowid = last_insert_rowid()`);
      const timesheetId = timesheetRows[0].id;
      
      // Insert activities
      for (const activity of data.activities) {
        await this.createTimesheetActivity({
          timesheetId,
          activityId: activity.activityId,
          hours: activity.hours,
          hourlyRate: activity.hourlyRate,
          total: activity.total,
          description: activity.description,
          position: activity.position
        });
      }
      
      const newTimesheet = await this.getTimesheet(timesheetId);
      if (!newTimesheet) throw new Error("Timesheet creation failed");
      return newTimesheet;
    });
  }

  async updateTimesheet(id: number, patch: Partial<Timesheet>): Promise<Timesheet> {
    return withTx(async () => {
      const current = await this.getTimesheet(id);
      if (!current) throw new Error("Timesheet not found");

      const next = { ...current, ...patch, updatedAt: nowIso() };

      run(
        `
        UPDATE timesheets SET
          timesheetNumber = ?, customerId = ?, title = ?, status = ?, startDate = ?, endDate = ?, 
          subtotal = ?, vatRate = ?, vatAmount = ?, total = ?, notes = ?, updatedAt = ?
        WHERE id = ?
      `,
        [
          next.timesheetNumber,
          next.customerId,
          next.title,
          next.status,
          next.startDate,
          next.endDate,
          next.subtotal,
          next.vatRate,
          next.vatAmount,
          next.total,
          next.notes || null,
          next.updatedAt,
          id,
        ]
      );

      // Update activities if provided
      if (patch.activities) {
        // Delete old activities
        run(`DELETE FROM timesheet_activities WHERE timesheetId = ?`, [id]);
        
        // Insert new activities
        for (const activity of patch.activities) {
          await this.createTimesheetActivity({
            timesheetId: id,
            activityId: activity.activityId,
            hours: activity.hours,
            hourlyRate: activity.hourlyRate,
            total: activity.total,
            description: activity.description,
            position: activity.position
          });
        }
      }

      const updated = await this.getTimesheet(id);
      if (!updated) throw new Error("Timesheet update failed");
      return updated;
    });
  }

  async deleteTimesheet(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM timesheets WHERE id = ?`, [id]);
    });
  }

  // ACTIVITIES
  async listActivities(): Promise<Activity[]> {
    await getDB();
    return all<Activity>(`SELECT * FROM activities ORDER BY name ASC`);
  }

  async getActivity(id: number): Promise<Activity | null> {
    await getDB();
    const rows = all<Activity>(`SELECT * FROM activities WHERE id = ?`, [id]);
    return rows[0] ?? null;
  }

  async createActivity(data: Omit<Activity, "id" | "createdAt" | "updatedAt">): Promise<Activity> {
    return withTx(async () => {
      const ts = nowIso();
      
      run(
        `INSERT INTO activities (name, description, defaultHourlyRate, isActive, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?)`,
        [data.name, data.description || null, data.defaultHourlyRate, data.isActive ? 1 : 0, ts, ts]
      );
      
      const activityRows = all<{ id: number }>(`SELECT id FROM activities WHERE rowid = last_insert_rowid()`);
      const activityId = activityRows[0].id;
      
      const newActivity = await this.getActivity(activityId);
      if (!newActivity) throw new Error("Activity creation failed");
      return newActivity;
    });
  }

  async updateActivity(id: number, patch: Partial<Activity>): Promise<Activity> {
    return withTx(async () => {
      const current = await this.getActivity(id);
      if (!current) throw new Error("Activity not found");

      const next = { ...current, ...patch, updatedAt: nowIso() };

      run(
        `UPDATE activities SET name = ?, description = ?, defaultHourlyRate = ?, isActive = ?, updatedAt = ? WHERE id = ?`,
        [next.name, next.description || null, next.defaultHourlyRate, next.isActive ? 1 : 0, next.updatedAt, id]
      );

      const updated = await this.getActivity(id);
      if (!updated) throw new Error("Activity update failed");
      return updated;
    });
  }

  async deleteActivity(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM activities WHERE id = ?`, [id]);
    });
  }

  // TIMESHEET ACTIVITIES
  async getTimesheetActivities(timesheetId: number): Promise<TimesheetActivity[]> {
    await getDB();
    return all<TimesheetActivity>(`SELECT * FROM timesheet_activities WHERE timesheetId = ? ORDER BY id`, [timesheetId]);
  }

  async createTimesheetActivity(data: Omit<TimesheetActivity, "id">): Promise<TimesheetActivity> {
    return withTx(async () => {
      return this.createTimesheetActivity(data);
    });
  }

  async updateTimesheetActivity(id: number, patch: Partial<TimesheetActivity>): Promise<TimesheetActivity> {
    return withTx(async () => {
      const current = all<TimesheetActivity>(`SELECT * FROM timesheet_activities WHERE id = ?`, [id])[0];
      if (!current) throw new Error("Timesheet activity not found");

      const next = { ...current, ...patch };

      run(
        `UPDATE timesheet_activities SET timesheetId = ?, activityId = ?, hours = ?, hourlyRate = ?, total = ?, description = ?, position = ? WHERE id = ?`,
        [next.timesheetId, next.activityId, next.hours, next.hourlyRate, next.total, next.description || null, next.position || null, id]
      );

      const updated = all<TimesheetActivity>(`SELECT * FROM timesheet_activities WHERE id = ?`, [id]);
      if (!updated[0]) throw new Error("Timesheet activity update failed");
      return updated[0];
    });
  }

  async deleteTimesheetActivity(id: number): Promise<void> {
    await withTx(async () => {
      run(`DELETE FROM timesheet_activities WHERE id = ?`, [id]);
    });
  }

  /**
   * üîß DATA FIX: Korrigiert Line Items mit undefined/null unitPrice und total
   * Berechnet fehlende Werte basierend auf quantity * unitPrice = total
   */
  async fixLineItemPrices(): Promise<{ fixed: number; errors: string[] }> {
    let fixed = 0;
    const errors: string[] = [];

    try {
      await withTx(async () => {
        // Fix Offer Line Items
        const offerItems = all<any>(`
          SELECT id, offerId, quantity, unitPrice, total 
          FROM offer_line_items 
          WHERE unitPrice IS NULL OR total IS NULL OR unitPrice = 0 OR total = 0
        `);

        for (const item of offerItems) {
          try {
            // Default values for missing prices
            const quantity = item.quantity || 1;
            const unitPrice = item.unitPrice || 0;
            const total = item.total || 0;
            
            // Calculate missing values
            let newUnitPrice = unitPrice;
            let newTotal = total;
            
            if ((unitPrice === 0 || unitPrice === null) && total > 0) {
              // Calculate unitPrice from total and quantity
              newUnitPrice = total / quantity;
            } else if ((total === 0 || total === null) && unitPrice > 0) {
              // Calculate total from unitPrice and quantity
              newTotal = unitPrice * quantity;
            } else if (unitPrice === 0 && total === 0) {
              // Set reasonable defaults for completely empty items
              newUnitPrice = 0;
              newTotal = 0;
            }

            run(`
              UPDATE offer_line_items 
              SET unitPrice = ?, total = ? 
              WHERE id = ?
            `, [newUnitPrice, newTotal, item.id]);
            
            fixed++;
          } catch (error) {
            errors.push(`Failed to fix offer line item ${item.id}: ${error}`);
          }
        }

        // Fix Invoice Line Items (same logic)
        const invoiceItems = all<any>(`
          SELECT id, invoiceId, quantity, unitPrice, total 
          FROM invoice_line_items 
          WHERE unitPrice IS NULL OR total IS NULL OR unitPrice = 0 OR total = 0
        `);

        for (const item of invoiceItems) {
          try {
            const quantity = item.quantity || 1;
            const unitPrice = item.unitPrice || 0;
            const total = item.total || 0;
            
            let newUnitPrice = unitPrice;
            let newTotal = total;
            
            if ((unitPrice === 0 || unitPrice === null) && total > 0) {
              newUnitPrice = total / quantity;
            } else if ((total === 0 || total === null) && unitPrice > 0) {
              newTotal = unitPrice * quantity;
            } else if (unitPrice === 0 && total === 0) {
              newUnitPrice = 0;
              newTotal = 0;
            }

            run(`
              UPDATE invoice_line_items 
              SET unitPrice = ?, total = ? 
              WHERE id = ?
            `, [newUnitPrice, newTotal, item.id]);
            
            fixed++;
          } catch (error) {
            errors.push(`Failed to fix invoice line item ${item.id}: ${error}`);
          }
        }
      });

      console.log(`‚úÖ Line Item Data Fix: ${fixed} items corrected, ${errors.length} errors`);
      return { fixed, errors };
    } catch (error) {
      errors.push(`Transaction failed: ${error}`);
      return { fixed, errors };
    }
  }

  // LIST PREFERENCES
  async getListPreferences(): Promise<ListPreferences> {
    await getDB();
    const settings = await this.getSettings();
    
    try {
      return settings.listPreferences ? JSON.parse(settings.listPreferences) : {};
    } catch (error) {
      console.warn('Error parsing listPreferences:', error);
      return {};
    }
  }

  async setListPreferences(preferences: ListPreferences): Promise<void> {
    return withTx(async () => {
      const serialized = JSON.stringify(preferences);
      
      run(
        `UPDATE settings SET listPreferences = ?, updatedAt = ? WHERE id = 1`,
        [serialized, nowIso()]
      );
    });
  }

  async updateListPreference(entity: EntityKey, preference: Partial<ListPreference>): Promise<void> {
    return withTx(async () => {
      const current = await this.getListPreferences();
      const entityPrefs = current[entity] || {};
      const updated = { ...entityPrefs, ...preference };
      
      const newPreferences = { ...current, [entity]: updated };
      await this.setListPreferences(newPreferences);
    });
  }
}

