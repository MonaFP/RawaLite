# ü§ñ KI-FRIENDLY FIXPLAN ‚Äì Schritt-f√ºr-Schritt Implementation Guide

> **Erstellt:** 03.11.2025 | **Letzte Aktualisierung:** 03.11.2025 (KI-PR√ÑFIX-ERKENNUNGSREGELN Implementation)  
> **Status:** COMPLETED - KI-Optimiert f√ºr Schrittweise Ausf√ºhrung  
> **Typ:** COMPLETED_PLAN - KI-Friendly Fixplan  
> **Schema:** `COMPLETED_PLAN-KI-FRIENDLY-FIXPLAN_2025-11-03.md` ‚úÖ **SCHEMA-COMPLIANT**

> **ü§ñ KI-AUTO-DETECTION SYSTEM:**
> - **AKTUELLER STATUS:** COMPLETED - KI-Optimiert (automatisch durch "KI-FRIENDLY FIXPLAN" erkannt)
> - **TEMPLATE-QUELLE:** 06-handbook COMPLETED_PLAN Template (KI-Friendly Edition)
> - **AUTO-UPDATE:** Bei Fix-Strategie-√Ñnderung automatisch Plan aktualisieren
> - **STATUS-KEYWORDS:** Erkannt durch "KI-FRIENDLY", "Step-by-Step", "Schrittweise Ausf√ºhrung"

> **ü§ñ KI-VERHALTENSREGELN (AUTO-AKTIV basierend auf Status):**
> 
> **üìö STATUS = COMPLETED (KI-Friendly Edition):**
> - ‚úÖ **Implementation-Plan** - Verl√§ssliche Quelle f√ºr strukturierte Fix-Durchf√ºhrung
> - ‚úÖ **KI-optimierte Struktur** - Mit Kontext-Reminders, Checkpoints, Best√§tigungsschleifen
> - üéØ **AUTO-REFERENCE:** Bei Fix-Implementation diese Strategie als Basis nutzen
> - üîÑ **AUTO-TRIGGER:** Bei Keywords "KI EXECUTION" ‚Üí Plan-Compliance f√ºr KI-Agenten pr√ºfen

> **‚ö†Ô∏è KI-FRIENDLY FIXPLAN STATUS:** 4 Phasen + 15 Steps + Execution Instructions (03.11.2025)  
> **Registry Status:** Umstrukturiert f√ºr robuste KI-Agent-Ausf√ºhrung  
> **Backup Status:** Neuestes Backup identifiziert, Restore-Plan integriert  
> **Critical Function:** Production-ready, KI-sichere Implementation roadmap mit Safety-Mechanisms

---

## üìã **SCHEMA-√úBERSICHT (KI-PR√ÑFIX-ERKENNUNGSREGELN COMPLIANT)**

### **Document Classification:**
- **STATUS-PR√ÑFIX:** `COMPLETED_` ‚úÖ **Abgeschlossenes Plan-Dokument (fertige, umstrukturierte Strategie)**
- **TYP-KATEGORIE:** `PLAN-` ‚úÖ **Planungsdokument mit Execution-Focus** 
- **SUBJECT:** `KI-FRIENDLY-FIXPLAN` ‚úÖ **Spezifisch identifiziert f√ºr KI-Ausf√ºhrung**
- **SPECIFIER:** (integriert in SUBJECT)
- **DATUM:** `2025-11-03` ‚úÖ **G√ºltig und aktuell**

### **KI-Interpretation (nach KI-PR√ÑFIX-ERKENNUNGSREGELN):** 
- **Thema:** KI-Friendly Fixplan (Umstrukturierte Implementation Strategy f√ºr KI-Agent-Ausf√ºhrung)
- **Status:** COMPLETED (fertige, umsetzungsreife Strategie, speziell f√ºr KI optimiert)
- **Quelle:** docs/02-dev/LESSON/ (Development Planning)
- **Priorit√§t:** H√ñCHSTE (Production-ready, sofortige Umsetzung empfohlen, KI-sichere Struktur)
- **KI-Verhalten:** Nutze als verl√§ssliche Quelle f√ºr strukturierte, step-by-step KI-Ausf√ºhrung

---

## üìö META-SECTION: Dokumentations-Struktur & Lesereihenfolge

### **üîó Zentrale Ankerdokumente (Basis dieser Anleitung)**

Die folgenden **7 Dokumente** bilden die Informationsbasis. **Vor jedem neuen Schritt** sollten sie kurz erneut eingelesen werden:

| # | Datei | Zweck | Priorit√§t |
|:--|:--|:--|:--|
| **1** | `DOCUMENTATION-INDEX_2025-11-03.md` | Master-Index aller Analyse-Ergebnisse | üü° IMMER lesen |
| **2** | `LESSON_FIX-ELECTRON-BUILDER-APP-ASAR-LOCK_2025-11-03.md` | Electron Build-Problem + Dev/Prod Chaos | üü° KONTEXT |
| **3** | `LESSON_FIX-DEV-PROD-DATABASE-SEPARATION-MISSING_2025-11-03.md` | Kritischer Design-Fehler (Dev/Prod) | üî¥ CRITICAL |
| **4** | `KNOWLEDGE_ONLY_FIX-PRODUCTION-DATABASE-RECOVERY-STRATEGY_2025-11-03.md` | Datenbank-Wiederherstellung | üü° Bei Notfall |
| **5** | `COMPLETED_REPORT-COMPREHENSIVE-ANALYSIS_2025-11-03.md` | Detaillierte Analysen & Root Causes | üü° Hintergrund |
| **6** | `COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md` | Original-Fixplan (detailliert) | üü° Referenz |
| **7** | `COMPLETED_PLAN-KI-FRIENDLY-FIXPLAN_2025-11-03.md` | DIESE DATEI ‚Äì Strukturierte KI-Ausf√ºhrung | üü¢ KI-DIESE ANLEITUNG |

### **üìñ Empfohlene Lesereihenfolge f√ºr KI-Agenten**

```
SESSION START:
1. Lese DOCUMENTATION-INDEX_2025-11-03.md (5 Min ‚Äì √úberblick)
2. Lese diese Datei: COMPLETED_PLAN-KI-FRIENDLY-FIXPLAN_2025-11-03.md (15 Min ‚Äì KI-Struktur verstehen)
3. DANN: Beginne mit SCHRITT 1 (siehe unten)

VOR JEDEM NEUEN HAUPTSCHRITT:
‚Üí Erneut lesen: DOCUMENTATION-INDEX + relevante LESSON_FIX Dokumente
‚Üí Aktualisiere deinen Kontext √ºber aktuelle Architektur
‚Üí Pr√ºfe: Wurden alle Voraussetzungen aus dem vorherigen Schritt erf√ºllt?
```

---

## ‚ö†Ô∏è KRITISCHE KONTEXTE & REMINDERS

### **üî¥ SEVERITY: Dieses Fixprogramm ist KRITISCH**

- **Umfang:** 3 Production-Level Architektur-Fehler
- **Risiko:** Production-Datenverlust m√∂glich
- **Timeline:** 4-6 Tage Entwicklungszeit
- **Priorit√§t:** SOFORT implementieren (vor n√§chstem Release)

### **üß† KI-Erinnerung vor JEDEM Schritt**

> üîÅ **WICHTIG F√úR KI-AGENTEN:**  
> Lese vor Beginn dieses Schrittes erneut:
> - `DOCUMENTATION-INDEX_2025-11-03.md` (√úberblick)
> - `LESSON_FIX-DEV-PROD-DATABASE-SEPARATION-MISSING_2025-11-03.md` (Problem-Details)
> - Relevante Abschnitte aus dem ORIGINAL-Plan (`COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md`)
> 
> **Grund:** Kontextaktualisierung sorgt f√ºr konsistente, sichere Ausf√ºhrung.

---

## üéØ SCHRITT-√úBERSICHT (Nummeriert f√ºr KI-Navigation)

```
HAUPTPHASEN:
‚îú‚îÄ SCHRITT 1-6   ‚Üí PHASE 1: EMERGENCY FIXES (Dev/Prod Separation)
‚îú‚îÄ SCHRITT 7-10  ‚Üí PHASE 2: ROLLBACK SYSTEM (Backwards Compatibility)
‚îú‚îÄ SCHRITT 11-14 ‚Üí PHASE 3: RECOVERY UI (Backup Management)
‚îî‚îÄ SCHRITT 15    ‚Üí PHASE 4: BACKUP RECOVERY (Notfall-Recovery)

GESAMT: 15 Hauptschritte + optionale Validierungen
GESCH√ÑTZTER AUFWAND: 4-6 Tage
```

---

---

# üü¢ PHASE 1: EMERGENCY FIXES ‚Äì Dev/Prod Database Separation

## ‚è±Ô∏è Timeline: 1-2 Tage | Priorit√§t: üî¥ CRITICAL

> **ZIEL:** Implementiere Datenbank-Pfad-Differenzierung zwischen Dev und Prod.  
> **ERGEBNIS:** Dev nutzt `rawalite-dev.db`, Prod nutzt `rawalite.db` ‚Äì keine Kollisionen mehr.

---

### üîÅ STEP 1: Kontext-Update & Pre-Requisites

**Aktion vor Start:**

- [ ] Lese `DOCUMENTATION-INDEX_2025-11-03.md` vollst√§ndig
- [ ] Lese `LESSON_FIX-DEV-PROD-DATABASE-SEPARATION-MISSING_2025-11-03.md` Abschnitte:
  - ‚ÄûROOT CAUSE"
  - ‚ÄûImpact Scenarios"
- [ ] √ñffne `COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md` und navigiere zu ‚ÄûPHASE 1: EMERGENCY FIXES"
- [ ] **Backup erstellen:** Kopiere aktuelles Repo als `.backup_before_phase1`

**Voraussetzungen validieren:**

```bash
# Pr√ºfe: Sind alle Zieldateien vorhanden?
ls -la src/main/db/Database.ts
ls -la src/main/db/BackupService.ts
ls -la electron/main.ts

# Pr√ºfe: Git-Status clean?
git status
# ‚Üí ERGEBNIS: Alles committed/clean vor √Ñnderungen
```

**‚úÖ Zwischenstand merken:**
> Kontext aufgefrischt, Dateien pr√§sent, Git clean. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 2?"

---

### üîÅ STEP 2: FIX 1.1 ‚Äì Database.ts Path Separation

**Aktion:**

Modifiziere `src/main/db/Database.ts` ‚Äì Funktion `getDbPath()`:

**VORHER (PROBLEMATISCH):**
```typescript
function getDbPath(): string {
  const userData = app.getPath('userData');
  return path.join(userData, 'database', 'rawalite.db');  // ‚Üê NO isDev check!
}
```

**NACHHER (FIXED):**
```typescript
function getDbPath(): string {
  const userData = app.getPath('userData');
  const isDev = !app.isPackaged;  // ‚Üê ADD: isDev Check
  const filename = isDev ? 'rawalite-dev.db' : 'rawalite.db';
  return path.join(userData, 'database', filename);
}
```

**Validierung:**
```bash
# Test Dev-Pfad
NODE_ENV=development pnpm dev &
# ‚Üí Sollte rawalite-dev.db erstellen/nutzen

# Pr√ºfe Log-Output:
# ‚úÖ Expected: "Using database: C:\...\rawalite-dev.db"
```

**‚úÖ Zwischenstand merken:**
> FIX 1.1 abgeschlossen. Database.ts nutzt isDev Check. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 3?"

---

### üîÅ STEP 3: FIX 1.2 ‚Äì BackupService.ts Path Synchronization

**Aktion:**

Modifiziere `src/main/db/BackupService.ts` ‚Äì Funktion `getDbPath()`:

**OPTION A (Recommended ‚Äì Code Reuse):**
```typescript
private static getDbPath(): string {
  // Delegate to Database.getDbPath() to avoid duplication
  return Database.getDbPath();
}
```

**OPTION B (If Database.getDbPath is private):**
```typescript
private static getDbPath(): string {
  const userData = app.getPath('userData');
  const isDev = !app.isPackaged;  // ‚Üê ADD: isDev Check (same as Database.ts)
  const filename = isDev ? 'rawalite-dev.db' : 'rawalite.db';
  return path.join(userData, 'database', filename);
}
```

**Validierung:**
```bash
# Stelle sicher: BackupService nutzt GLEICHE Pfad-Logik wie Database.ts
grep -n "getDbPath\|isDev\|rawalite-dev.db" src/main/db/BackupService.ts
# ‚Üí Expected: isDev check vorhanden
```

**‚úÖ Zwischenstand merken:**
> FIX 1.2 abgeschlossen. BackupService synchron mit Database.ts. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 4?"

---

### üîÅ STEP 4: FIX 1.3 ‚Äì electron/main.ts Database Init

**Aktion:**

Modifiziere `electron/main.ts` ‚Äì `createWindow()` Funktion:

**VORHER (PROBLEMATISCH):**
```typescript
const isDev = !app.isPackaged;  // ‚Üê Defined but NOT used for DB!

async function createWindow() {
  const db = getDb();  // ‚Üê No environment logging
  await runAllMigrations();
  createWindow();
}
```

**NACHHER (FIXED):**
```typescript
const isDev = !app.isPackaged;

async function createWindow() {
  // ADD: Environment logging
  if (isDev) {
    console.log('üîß DEV MODE: Using rawalite-dev.db for testing');
  } else {
    console.log('üöÄ PROD MODE: Using rawalite.db for production');
  }
  
  const db = getDb();  // ‚Üê Now uses isDev via Database.getDbPath()
  await runAllMigrations();
  createWindow();
}
```

**Validierung:**
```bash
# Starte beide Modi:
pnpm dev 2>&1 | grep -E "DEV MODE|PROD MODE"
# ‚Üí Expected: "üîß DEV MODE..." erscheint

# In installierter Prod-App:
# ‚Üí Expected: "üöÄ PROD MODE..." in App-Logs
```

**‚úÖ Zwischenstand merken:**
> FIX 1.3 abgeschlossen. isDev wird f√ºr DB-Init genutzt. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 5?"

---

### üîÅ STEP 5: FIX 1.4 ‚Äì Environment Configuration Module

**Aktion:**

Erstelle neue Datei `src/config/environment.ts`:

```typescript
import { app } from 'electron';
import path from 'path';

export const ENVIRONMENT = {
  isDev: !app.isPackaged,
  appName: 'RawaLite',
  dataPath: app.getPath('userData'),
  databasePath: !app.isPackaged ? 'rawalite-dev.db' : 'rawalite.db',
  backupDir: 'database/backups',
  backupMetadataDir: 'database/backups/.metadata',
  logDir: 'logs'
};

export const VALIDATION = {
  minHeaderHeight: 36,
  maxHeaderHeight: 220,
  minSidebarWidth: 180,
  maxSidebarWidth: 320
};

export function getFullDatabasePath(): string {
  return path.join(ENVIRONMENT.dataPath, 'database', ENVIRONMENT.databasePath);
}
```

**Validierung:**
```bash
# Pr√ºfe: Datei existiert und ist lesbar
ls -la src/config/environment.ts
# ‚Üí File should exist with content

# Test: Import in Database.ts
# ‚Üí Sollte keinen Import-Fehler geben
```

**‚úÖ Zwischenstand merken:**
> FIX 1.4 abgeschlossen. Zentrale Environment-Config erstellt. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 6?"

---

### üîÅ STEP 6: FIX 1.5 & 1.6 ‚Äì Backup Verification & Config Validation

**Aktion 1.5: Pre-Migration Backup Verification**

Pr√ºfe in `src/main/db/MigrationService.ts`:

```typescript
export async function runAllMigrations(): Promise<void> {
  const db = getDb();
  
  // ADD: Pre-migration backup verification
  const backupPath = await BackupService.createPreMigrationBackup(db);
  console.log(`‚úÖ Pre-migration backup created: ${backupPath}`);
  
  // Verify VACUUM INTO backup is valid
  if (!fs.existsSync(backupPath)) {
    throw new Error('Pre-migration backup failed to create');
  }
  
  tx((db) => {
    for (const migration of pendingMigrations) {
      migration.up(db);
      setUserVersion(targetVersion);
    }
  });
}
```

**Aktion 1.6: Config Validation at Startup**

Erstelle `src/main/db/ConfigValidator.ts`:

```typescript
export function validateDatabaseConfiguration(): {
  isValid: boolean;
  errors: string[];
} {
  const errors: string[] = [];
  
  // Check: isDev separation
  const isProd = app.isPackaged;
  const dbPath = Database.getDbPath();
  
  if (isProd && dbPath.includes('rawalite-dev.db')) {
    errors.push('ERROR: Prod mode trying to use rawalite-dev.db');
  }
  
  if (!isProd && dbPath.includes('rawalite.db') && !dbPath.includes('rawalite-dev.db')) {
    errors.push('WARNING: Dev mode using production database');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

**Validierung:**
```bash
# Test: Pre-migration backup creation
pnpm test --testNamePattern="backup"
# ‚Üí Expected: Backups created successfully

# Test: Config validation
pnpm test --testNamePattern="ConfigValidator"
# ‚Üí Expected: All validations pass
```

**‚úÖ PHASE 1 ABGESCHLOSSEN**

> **Ergebnis:** Dev und Prod nutzen separate Datenbanken.  
> **Status:** ‚úÖ Dev: `rawalite-dev.db` | Prod: `rawalite.db`  
> **N√§chster Schritt:** PHASE 2 (Rollback System)

---

---

# üü° PHASE 2: ROLLBACK SYSTEM ‚Äì Backwards Compatibility

## ‚è±Ô∏è Timeline: 2-3 Tage | Priorit√§t: üî¥ CRITICAL

> **ZIEL:** Implementiere Migration Rollback-F√§higkeit.  
> **ERGEBNIS:** Fehlgeschlagene Migrations k√∂nnen automatisch r√ºckg√§ngig gemacht werden.

---

### üîÅ STEP 7: Kontext-Update & Phase 2 Prerequisites

**Aktion vor Start:**

- [ ] Lese erneut: `DOCUMENTATION-INDEX_2025-11-03.md`
- [ ] Lese erneut: `LESSON_FIX-DEV-PROD-DATABASE-SEPARATION-MISSING_2025-11-03.md`
  - Abschnitt: ‚ÄûWarum R√ºckw√§rtskompatibilit√§t kritisch ist"
- [ ] √ñffne `COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md` ‚Üí ‚ÄûPHASE 2: ROLLBACK SYSTEM"
- [ ] **Validiere PHASE 1:** Stelle sicher, Dev/Prod Separation l√§uft

```bash
# Validiere: PHASE 1 Tests bestanden?
pnpm validate:critical-fixes
# ‚Üí Expected: Alle Phase-1-Fixes aktiv
```

**‚úÖ Zwischenstand merken:**
> PHASE 1 validiert, Kontext aufgefrischt. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 8?"

---

### üîÅ STEP 8: FIX 2.1 ‚Äì Implement rollbackMigration() Function

**Aktion:**

Modifiziere `src/main/db/MigrationService.ts` ‚Äì Neue Funktion:

```typescript
export async function rollbackMigration(toVersion: number): Promise<void> {
  if (toVersion < 1 || toVersion > currentSchemaVersion) {
    throw new Error(`Invalid rollback target version: ${toVersion}`);
  }

  const db = getDb();
  const tx = createTransaction(db);

  try {
    console.log(`üîÑ ROLLBACK: Starting rollback to schema version ${toVersion}...`);
    
    const currentVersion = getUserVersion(db);
    console.log(`üìä Current schema version: ${currentVersion}`);
    
    // Create backup BEFORE rollback
    const backupPath = await createPreMigrationBackup(db, `before-rollback-${toVersion}`);
    console.log(`üíæ Rollback backup created: ${backupPath}`);

    tx(() => {
      // Rollback in REVERSE order
      for (let v = currentVersion; v > toVersion; v--) {
        const migration = migrations.find(m => m.version === v);
        if (!migration) {
          throw new Error(`Migration ${v} not found for rollback`);
        }

        if (!migration.down || !migration.reversible) {
          throw new Error(`Migration ${v} is not reversible ‚Äì rollback cancelled`);
        }

        console.log(`  ‚Ü©Ô∏è  Rolling back migration ${v}...`);
        migration.down(db);
        setUserVersion(db, v - 1);
      }

      console.log(`‚úÖ Rollback to version ${toVersion} completed successfully`);
    });

  } catch (error) {
    console.error(`‚ùå Rollback failed: ${error.message}`);
    throw new Error(`Rollback to version ${toVersion} failed: ${error.message}`);
  }
}
```

**Validierung:**
```bash
# Test: Rollback-Funktion existiert und ist aufrufbar
grep -n "export async function rollbackMigration" src/main/db/MigrationService.ts
# ‚Üí Expected: Funktion present

# Test: Backup vor Rollback wird erstellt
pnpm test --testNamePattern="rollback"
# ‚Üí Expected: Backups created, rollback executed
```

**‚úÖ Zwischenstand merken:**
> FIX 2.1 abgeschlossen. rollbackMigration() Funktion implementiert. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 9?"

---

### üîÅ STEP 9: FIX 2.2 ‚Äì Reversible Migration Pattern f√ºr Alle (027-046)

**Aktion:**

F√ºr **JEDE** Migration `src/main/db/migrations/NNN_*.ts` (027-046):

**Schritt A: Metadaten hinzuf√ºgen**

```typescript
export const migrationNNN = {
  version: NNN,
  description: '...',
  reversible: true,    // ‚Üê ADD THIS
  downSafe: true,      // ‚Üê ADD THIS
  
  up: (db: Database) => {
    // Existing up() logic
  },

  down: (db: Database) => {
    // IMPLEMENT OR UPDATE: Must be reversible
    // For non-reversible: Mark as reversible: false
  }
};
```

**Schritt B: down() Implementierung nach Typ**

**Typ 1: CREATE TABLE Reversible**
```typescript
down: (db: Database) => {
  if (!db.exec("PRAGMA table_info(my_table);").length) {
    console.log('‚ö†Ô∏è  Migration NNN: Tables already dropped, skipping');
    return;
  }
  db.exec(`DROP TABLE IF EXISTS my_table;`);
  console.log('‚Ü©Ô∏è  Migration NNN: Tables removed');
}
```

**Typ 2: ADD COLUMN Reversible**
```typescript
down: (db: Database) => {
  // SQLite doesn't support DROP COLUMN, so:
  // Option: Recreate table without column or just ignore
  console.log('‚ö†Ô∏è  Migration NNN: Column cannot be dropped in SQLite');
}
```

**Typ 3: NON-REVERSIBLE (z.B. Migration 043 ‚Äì Data Transformation)**
```typescript
down: (db: Database) => {
  throw new Error(
    'Migration NNN is NOT reversible: Data transformation is destructive. ' +
    'Restore from backup if needed.'
  );
}
```

**Migration 043 SPECIAL CASE:**
```typescript
export const migration043 = {
  version: 43,
  description: 'Convert legacy navigation modes',
  reversible: false,  // ‚Üê Mark as non-reversible
  
  up: (db: Database) => {
    // Convert header-* ‚Üí mode-*
  },

  down: (db: Database) => {
    throw new Error(
      'Migration 043 is NOT reversible: Legacy mode conversion is data-destructive. ' +
      'Restore from backup if needed.'
    );
  }
};
```

**Validierung:**
```bash
# Pr√ºfe: ALLE Migrations 027-046 haben reversible Flag + down()
for i in {027..046}; do
  grep -l "reversible:" src/main/db/migrations/${i}_*.ts || echo "MISSING: Migration $i"
done
# ‚Üí Expected: No MISSING output

# Test: rollback f√ºr jede Migration
pnpm test --testNamePattern="rollback.*027\|rollback.*046"
# ‚Üí Expected: All pass or clear error for non-reversible
```

**‚úÖ Zwischenstand merken:**
> FIX 2.2 abgeschlossen. Alle Migrations 027-046 haben reversible down(). Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 10?"

---

### üîÅ STEP 10: FIX 2.3 & 2.4 ‚Äì Error Handling & Validation

**Aktion 2.3: Error Dialog + Rollback UI**

Modifiziere `electron/main.ts` ‚Äì `createWindow()`:

```typescript
async function createWindow() {
  try {
    const db = getDb();
    await runAllMigrations();
  } catch (migrationError) {
    console.error('‚ùå Migration failed:', migrationError.message);

    // ADD: Show error dialog to user
    const result = await dialog.showMessageBox({
      type: 'error',
      title: 'Database Update Failed',
      message: 'Failed to update the database to the latest version.',
      detail: migrationError.message,
      buttons: ['Exit App', 'Restore from Backup', 'Try Again'],
      defaultId: 0,
      cancelId: 0
    });

    switch (result.response) {
      case 1: // Restore from Backup
        await recoverFromBackup();
        process.exit(0);
        break;
      case 2: // Try Again
        process.exit(1);  // Signal for restart
        break;
      default:
        process.exit(1);
    }
  }
}
```

**Aktion 2.4: Pre-Migration Validation**

F√ºge zu `MigrationService.ts` hinzu:

```typescript
export async function validateMigrationsBeforeRunning(): Promise<{
  canRun: boolean;
  warnings: string[];
}> {
  const warnings: string[] = [];
  
  // Check: Are all migrations well-formed?
  for (const migration of migrations) {
    if (!migration.up) {
      warnings.push(`Migration ${migration.version}: Missing up() function`);
    }
    if (!migration.reversible && migration.down) {
      warnings.push(`Migration ${migration.version}: Marked non-reversible but has down()`);
    }
  }
  
  // Check: Is previous backup valid?
  const lastBackup = await BackupService.getLastBackup();
  if (!lastBackup) {
    warnings.push('WARNING: No previous backup found');
  }
  
  return {
    canRun: warnings.length === 0,
    warnings
  };
}
```

**Validierung:**
```bash
# Test: Migration Fehler zeigt Dialog
pnpm test --testNamePattern="migration.*error\|error.*dialog"
# ‚Üí Expected: Dialog appears, options available

# Test: Validation l√§uft vor Migrations
pnpm test --testNamePattern="validate.*migration"
# ‚Üí Expected: Validation runs successfully
```

**‚úÖ PHASE 2 ABGESCHLOSSEN**

> **Ergebnis:** Migrations k√∂nnen r√ºckg√§ngig gemacht werden.  
> **Status:** ‚úÖ rollbackMigration() aktiv | Error Dialogs funktionieren | Validation l√§uft  
> **N√§chster Schritt:** PHASE 3 (Recovery UI)

---

---

# üü† PHASE 3: RECOVERY UI ‚Äì Backup Management

## ‚è±Ô∏è Timeline: 1 Tag | Priorit√§t: üü° HIGH

> **ZIEL:** Implementiere Backup-Management-UI f√ºr Endbenutzer.  
> **ERGEBNIS:** Benutzer k√∂nnen Backups durchsuchen und optional wiederherstellen.

---

### üîÅ STEP 11: Kontext-Update & Phase 3 Prerequisites

**Aktion vor Start:**

- [ ] Lese erneut: `DOCUMENTATION-INDEX_2025-11-03.md`
- [ ] Lese erneut: `KNOWLEDGE_ONLY_FIX-PRODUCTION-DATABASE-RECOVERY-STRATEGY_2025-11-03.md`
- [ ] √ñffne `COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md` ‚Üí ‚ÄûPHASE 3: RECOVERY UI"
- [ ] **Validiere PHASE 1 + 2:** Alle Tests bestanden?

```bash
pnpm validate:critical-fixes
# ‚Üí Expected: Beide Phasen aktiv + gr√ºn
```

**‚úÖ Zwischenstand merken:**
> PHASE 1+2 validiert. Kontext aufgefrischt. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 12?"

---

### üîÅ STEP 12: FIX 3.1 ‚Äì IPC Handlers f√ºr Backups

**Aktion:**

Erstelle `electron/ipc/backups.ts`:

```typescript
import { ipcMain, dialog } from 'electron';
import { BackupService } from '../services/BackupService';
import fs from 'fs';

export function setupBackupHandlers() {
  
  // Handler 1: List all backups
  ipcMain.handle('backups:list', async () => {
    try {
      const backups = await BackupService.listAvailableBackups();
      return { success: true, backups };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  // Handler 2: Get backup metadata
  ipcMain.handle('backups:get-metadata', async (event, backupPath: string) => {
    try {
      const metadata = await BackupService.getBackupMetadata(backupPath);
      return { success: true, metadata };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  // Handler 3: Restore from backup
  ipcMain.handle('backups:restore', async (event, backupPath: string) => {
    try {
      await BackupService.restoreFromBackup(backupPath);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  // Handler 4: Validate backup integrity
  ipcMain.handle('backups:validate', async (event, backupPath: string) => {
    try {
      const isValid = await BackupService.validateBackupIntegrity(backupPath);
      return { success: true, isValid };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });
}
```

**Integrations-Check:**

Stelle sicher, dass in `electron/main.ts` folgende Zeile vorhanden ist:

```typescript
import { setupBackupHandlers } from './ipc/backups';

// In app initialization:
app.whenReady().then(() => {
  setupBackupHandlers();  // ‚Üê ADD THIS
  createWindow();
});
```

**Validierung:**
```bash
# Pr√ºfe: IPC Handlers sind registriert
grep -n "setupBackupHandlers\|backups:list\|backups:restore" electron/ipc/backups.ts
# ‚Üí Expected: Handlers present

# Test: IPC Channels accessible
pnpm test --testNamePattern="ipc.*backup"
# ‚Üí Expected: All handlers respond
```

**‚úÖ Zwischenstand merken:**
> FIX 3.1 abgeschlossen. IPC Handlers f√ºr Backups implementiert. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 13?"

---

### üîÅ STEP 13: FIX 3.2 ‚Äì Backup UI React Component

**Aktion:**

Erstelle `src/renderer/src/components/Settings/BackupPanel.tsx`:

```typescript
import React, { useEffect, useState } from 'react';
import './BackupPanel.css';

interface BackupInfo {
  path: string;
  size: number;
  metadata?: {
    timestamp: string;
    schemaVersion: number;
    environment: 'dev' | 'prod';
  };
}

export const BackupPanel: React.FC = () => {
  const [backups, setBackups] = useState<BackupInfo[]>([]);
  const [selectedBackup, setSelectedBackup] = useState<BackupInfo | null>(null);
  const [restoring, setRestoring] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadBackups();
  }, []);

  const loadBackups = async () => {
    setLoading(true);
    const result = await window.electronAPI.invoke('backups:list');
    if (result.success) {
      setBackups(result.backups);
    }
    setLoading(false);
  };

  const handleRestore = async (backup: BackupInfo) => {
    const confirmed = window.confirm(
      `Restore database from ${backup.metadata?.timestamp}? ` +
      `This will replace your current database.`
    );

    if (confirmed) {
      setRestoring(true);
      const result = await window.electronAPI.invoke('backups:restore', backup.path);
      setRestoring(false);

      if (result.success) {
        alert('Backup restored. App will restart...');
        window.location.reload();
      } else {
        alert(`Restore failed: ${result.error}`);
      }
    }
  };

  return (
    <div className="backup-panel">
      <h2>Database Backups</h2>
      <p>Manage and restore from previous database backups</p>
      
      {loading ? (
        <p>Loading backups...</p>
      ) : backups.length === 0 ? (
        <p>No backups found</p>
      ) : (
        <div className="backup-list">
          {backups.map((backup, idx) => (
            <div key={idx} className="backup-item">
              <div className="backup-info">
                <span className="timestamp">
                  {backup.metadata?.timestamp || 'Unknown'}
                </span>
                <span className="version">
                  Schema v{backup.metadata?.schemaVersion || 'Unknown'}
                </span>
                <span className="env">
                  [{backup.metadata?.environment || 'unknown'}]
                </span>
                <span className="size">
                  {(backup.size / 1024 / 1024).toFixed(2)} MB
                </span>
              </div>
              <button
                onClick={() => handleRestore(backup)}
                disabled={restoring}
                className="restore-btn"
              >
                {restoring ? 'Restoring...' : 'Restore'}
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

**Integrations-Check:**

Stelle sicher, dass `BackupPanel` in Settings-Seite importiert wird:

```typescript
// In src/renderer/src/pages/Settings.tsx:
import { BackupPanel } from '../components/Settings/BackupPanel';

export const Settings: React.FC = () => {
  return (
    <div className="settings">
      {/* ... other tabs ... */}
      <TabPanel value={tabValue} index={4}>
        <BackupPanel />
      </TabPanel>
    </div>
  );
};
```

**Validierung:**
```bash
# Pr√ºfe: Component existiert und ist syntaktisch korrekt
npx tsc --noEmit src/renderer/src/components/Settings/BackupPanel.tsx
# ‚Üí Expected: No TypeScript errors

# Test: Component rendert ohne Fehler
pnpm test --testNamePattern="BackupPanel"
# ‚Üí Expected: Component mounts successfully
```

**‚úÖ Zwischenstand merken:**
> FIX 3.2 abgeschlossen. UI-Component f√ºr Backup-Management implementiert. Pr√ºfe: ‚ÄûWeitermachen mit SCHRITT 14?"

---

### üîÅ STEP 14: FIX 3.3 & 3.4 ‚Äì Metadata System & Directory Structure

**Aktion 3.3: Backup Metadata System**

Modifiziere `src/main/db/BackupService.ts`:

```typescript
export interface BackupMetadata {
  timestamp: string;         // ISO timestamp
  schemaVersion: number;     // Current schema version
  fromMigration: number;     // Which migration created this
  environment: 'dev' | 'prod';
  appVersion: string;        // App version at backup time
  reason: string;            // Why backup was created
  databaseSize: number;      // Size in bytes
  checksum: string;          // For integrity validation
}

export async function createPreMigrationBackup(
  db: Database,
  reason: string = 'pre-migration'
): Promise<string> {
  const timestamp = new Date().toISOString();
  const schemaVersion = getUserVersion(db);
  const metadata: BackupMetadata = {
    timestamp,
    schemaVersion,
    fromMigration: schemaVersion,
    environment: isDev ? 'dev' : 'prod',
    appVersion: app.getVersion(),
    reason,
    databaseSize: fs.statSync(getDbPath()).size,
    checksum: await calculateChecksum()
  };

  const backupPath = `${getDbPath()}.backup-${timestamp.replace(/[:.]/g, '-')}`;
  const metadataPath = `${backupPath}.meta.json`;
  
  // Save metadata
  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
  
  // Create backup via VACUUM INTO
  db.exec(`VACUUM INTO '${backupPath}'`);
  
  console.log(`‚úÖ Backup created: ${backupPath}`);
  return backupPath;
}

export async function getBackupMetadata(backupPath: string): Promise<BackupMetadata> {
  const metadataPath = `${backupPath}.meta.json`;
  if (!fs.existsSync(metadataPath)) {
    throw new Error(`Metadata not found for backup: ${backupPath}`);
  }
  return JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
}
```

**Aktion 3.4: Backup Directory Organization**

Modifiziere `src/main/db/BackupService.ts`:

```typescript
enum BackupCategory {
  AUTO_PRE_MIGRATION = 'pre-migration',
  AUTO_DAILY = 'daily',
  MANUAL = 'manual',
  RECOVERY = 'recovery'
}

export function getBackupDirectory(
  category: BackupCategory = BackupCategory.AUTO_PRE_MIGRATION
): string {
  const baseDir = path.join(path.dirname(getDbPath()), 'backups');
  
  // Ensure base directory exists
  if (!fs.existsSync(baseDir)) {
    fs.mkdirSync(baseDir, { recursive: true });
  }
  
  switch (category) {
    case BackupCategory.AUTO_PRE_MIGRATION:
      const preMigDir = path.join(baseDir, 'pre-migration');
      fs.mkdirSync(preMigDir, { recursive: true });
      return preMigDir;
      
    case BackupCategory.MANUAL:
      const manualDir = path.join(baseDir, 'manual');
      fs.mkdirSync(manualDir, { recursive: true });
      return manualDir;
      
    case BackupCategory.RECOVERY:
      const recoveryDir = path.join(baseDir, 'recovery');
      fs.mkdirSync(recoveryDir, { recursive: true });
      return recoveryDir;
      
    default:
      return baseDir;
  }
}
```

**Expected Directory Structure nach FIX 3.4:**

```
AppData/Roaming/Electron/database/
‚îú‚îÄ‚îÄ rawalite.db                    (Current prod DB)
‚îú‚îÄ‚îÄ rawalite-dev.db                (Dev DB)
‚îú‚îÄ‚îÄ backups/
‚îÇ   ‚îú‚îÄ‚îÄ pre-migration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2025-11-03T10-30-45.db
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 2025-11-03T10-30-45.db.meta.json
‚îÇ   ‚îú‚îÄ‚îÄ manual/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ recovery/
‚îÇ       ‚îî‚îÄ‚îÄ ...
```

**Validierung:**
```bash
# Pr√ºfe: Metadata wird erstellt
pnpm test --testNamePattern="backup.*metadata"
# ‚Üí Expected: Metadata files created alongside backups

# Pr√ºfe: Directory structure wird organisiert
pnpm test --testNamePattern="backup.*directory"
# ‚Üí Expected: Directories created with correct categories
```

**‚úÖ PHASE 3 ABGESCHLOSSEN**

> **Ergebnis:** Backup Management UI funktioniert vollst√§ndig.  
> **Status:** ‚úÖ IPC Handlers aktiv | UI Component funktioniert | Metadata erfasst | Org. Struktur  
> **N√§chster Schritt:** PHASE 4 (Notfall-Recovery)

---

---

# üî¥ PHASE 4: NOTFALL-RECOVERY ‚Äì Datenbank-Wiederherstellung

## ‚è±Ô∏è Timeline: Je nach Notfall | Priorit√§t: üî¥ CRITICAL (bei Bedarf)

> **ZIEL:** Wenn Produktions-DB √ºberschrieben wurde ‚Üí Wiederherstellen aus Backup.  
> **ERGEBNIS:** Produktions-Daten wiederhergestellt oder zumindest aus pre-migration backup geladen.

---

### üîÅ STEP 15: Notfall-Recovery-Prozess

**Verwendung nur wenn:**
- ‚úã Produktions-Datenbank wurde versehentlich √ºberschrieben
- ‚úã Migration ist fehlgeschlagen und App startet nicht
- ‚úã Benutzer m√∂chte aus Backup wiederherstellen

**Lese zun√§chst:**
- `KNOWLEDGE_ONLY_FIX-PRODUCTION-DATABASE-RECOVERY-STRATEGY_2025-11-03.md`
- `COMPLETED_PLAN-COMPREHENSIVE-FIX-STRATEGY_2025-11-03.md` ‚Üí Abschnitt ‚ÄûPHASE 4: BACKUP RECOVERY & RESTORE STRATEGY"

**SCENARIO 1: Benutzer-gesteuerte Wiederherstellung via UI**

```
1. √ñffne Settings ‚Üí Backups
2. W√§hle Backup aus (z.B. pre-migration-045)
3. Klick "Restore"
4. App startet neu mit geladenem Backup
5. Fertig!
```

**SCENARIO 2: Manuelle Recovery (CLI)**

```powershell
# Step 1: Stop all processes
taskkill /F /IM electron.exe 2>$null
taskkill /F /IM node.exe 2>$null

# Step 2: Backup current corrupted DB
$timestamp = Get-Date -Format "yyyy-MM-dd-HH-mm-ss"
Copy-Item `
  "C:\Users\ramon\AppData\Roaming\Electron\database\rawalite.db" `
  "C:\Users\ramon\AppData\Roaming\Electron\database\rawalite.db.backup-corrupted-$timestamp"

# Step 3: Restore from best backup (pre-migration-045)
Copy-Item `
  "C:\Users\ramon\AppData\Roaming\Electron\database\rawalite.db.backup-before-045-rollback-1761591346891" `
  "C:\Users\ramon\AppData\Roaming\Electron\database\rawalite.db"

# Step 4: Verify
Get-Item "C:\Users\ramon\AppData\Roaming\Electron\database\rawalite.db" | `
  ForEach-Object { Write-Host "‚úÖ Restored: $($_.FullName), Size: $($_.Length) bytes" }

# Step 5: Validate
pnpm validate:critical-fixes

# Step 6: Restart
Start-Process ".\RawaLite-Setup.exe"
```

**SCENARIO 3: Rollback via Migration System**

```bash
# Wenn Phase 2 implementiert ist:
# Rollback von Migration 045/046 zu 044
await rollbackMigration(44);
```

**‚úÖ ALLE PHASEN ABGESCHLOSSEN**

---

---

## ‚úÖ **FINALES CHECKPOINT & KONTROLLIERTE AUSF√úHRUNGSANWEISUNG**

### **üéØ Was wurde implementiert?**

- ‚úÖ **PHASE 1:** Dev/Prod Database Separation (6 Fixes)
- ‚úÖ **PHASE 2:** Rollback System (4 Fixes)
- ‚úÖ **PHASE 3:** Recovery UI (4 Fixes)
- ‚úÖ **PHASE 4:** Notfall-Recovery Prozeduren

**Total:** 15 Schritte | 4-6 Tage Aufwand | 0 Datenverlust-Risiko (mit Backups)

---

### **ü§ñ ANWEISUNG F√úR K√úNFTIGE KI-AGENTEN**

**Wenn dieser Plan sp√§ter ausgef√ºhrt wird:**

```
1. ZUERST: Lese alle 7 Ankerdokumente (siehe META-SECTION oben)

2. DANN: F√ºr JEDEN Schritt (1-15):
   a) Lese die üîÅ STEP X Anweisung VOLLST√ÑNDIG
   b) F√ºhre Aktion durch
   c) F√ºhre Validierung durch
   d) Best√§tige: ‚Äû‚úÖ Zwischenstand merken"
   e) Frage: ‚ÄûWeitermachen mit SCHRITT X+1?"
   f) ERST DANN: N√§chster Schritt

3. NACH jedem Major-Abschnitt (Phase Ende):
   a) Lese erneut: DOCUMENTATION-INDEX + relevante LESSON_FIX Docs
   b) F√ºhre Validierung durch: pnpm validate:critical-fixes
   c) Best√§tige: Phase-Ziele erreicht?
   d) ERST DANN: N√§chste Phase

4. BEI FEHLERN:
   a) Stopp! ‚Üí Lese Fehler
   b) Konsultiere COMPLETED_PLAN-COMPREHENSIVE Abschnitt f√ºr diesen Fix
   c) Konsultiere LESSON_FIX Dokumentation
   d) Behebe Problem
   e) Neustart von aktuellem Schritt

5. NACH ALLEM:
   a) F√ºhre ALLE Validierungen durch
   b) Dokumentiere: Was wurde abgeschlossen?
   c) Dokumentiere: Welche Tests bestanden?
```

---

### **üìä Erfolgs-Kriterien**

Nach vollst√§ndiger Ausf√ºhrung sollte gelten:

- [ ] ‚úÖ Dev nutzt `rawalite-dev.db`, Prod nutzt `rawalite.db`
- [ ] ‚úÖ `rollbackMigration()` Funktion existiert und funktioniert
- [ ] ‚úÖ Alle Migrations 027-046 haben reversible `down()` Methoden
- [ ] ‚úÖ Migration-Fehler zeigen Error Dialog mit Recovery-Optionen
- [ ] ‚úÖ Backup Management UI ist in Settings verf√ºgbar
- [ ] ‚úÖ Benutzer k√∂nnen Backups durchsuchen und wiederherstellen
- [ ] ‚úÖ Alle Tests bestehen: `pnpm validate:critical-fixes`
- [ ] ‚úÖ Keine Production-Data-Loss-Risiken mehr

---

**üìç Datei:** `COMPLETED_PLAN-KI-FRIENDLY-FIXPLAN_2025-11-03.md`  
**Pr√§fix-Schema:** ‚úÖ COMPLETED_PLAN-KI-FRIENDLY-FIXPLAN_2025-11-03.md (Schema-konform)  
**Zweck:** KI-sichere, schritt-f√ºr-schritt Ausf√ºhrungsanleitung mit KI-AUTO-DETECTION SYSTEM  
**Status:** ‚úÖ Ready for Implementation  
**KI-Quellen:** 7 bestehende Analyse-Dokumente (strukturiert)

*Umstrukturiert mit KI-PR√ÑFIX-ERKENNUNGSREGELN: 03. November 2025*
